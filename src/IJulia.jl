"""
**IJulia** is a [Julia-language](http://julialang.org/) backend
combined with the [Jupyter](http://jupyter.org/) interactive
environment (also used by [IPython](http://ipython.org/)).  This
combination allows you to interact with the Julia language using
Jupyter/IPython's powerful [graphical
notebook](http://ipython.org/notebook.html), which combines code,
formatted text, math, and multimedia in a single document.

The `IJulia` module is used in three ways

* Typing `using IJulia; notebook()` will launch the Jupyter notebook
  interface in your web browser.  This is an alternative to launching
  `jupyter notebook` directly from your operating-system command line.
* In a running notebook, the `IJulia` module is loaded and `IJulia.somefunctions`
  can be used to interact with the running IJulia kernel:

  - `IJulia.load(filename)` and `IJulia.load_string(s)` load the contents
    of a file or a string, respectively, into a notebook cell.
  - `IJulia.clear_output()` to clear the output from the notebook cell,
    useful for simple animations.
  - `IJulia.clear_history()` to clear the history variables `In` and `Out`.
  - `push_X_hook(f)` and `pop_X_hook(f)`, where `X` is either
    `preexecute`, `postexecute`, or `posterror`.  This allows you to
    insert a "hook" function into a list of functions to execute
    when notebook cells are evaluated.
  - `IJulia.set_verbose()` enables verbose output about what IJulia
    is doing internally; this is mainly used for debugging.

* It is used internally by the IJulia kernel when talking
  to the Jupyter server.
"""
module IJulia
export notebook, jupyterlab, installkernel

import MbedTLS
using ZMQ, JSON, SoftGlobalScope
import Base: invokelatest, RefValue
import Dates
using Dates: now, format, UTC, ISODateTimeFormat
import Random
import Random: seed!
using Base64: Base64EncodePipe
import REPL
import Logging

# InteractiveUtils is not used inside IJulia, but loaded in src/kernel.jl
# and this import makes it possible to load InteractiveUtils from the IJulia namespace
import InteractiveUtils

const depfile = joinpath(dirname(@__FILE__), "..", "deps", "deps.jl")
isfile(depfile) || error("IJulia not properly installed. Please run Pkg.build(\"IJulia\")")
include(depfile) # generated by Pkg.build("IJulia")

# use our own random seed for msg_id so that we
# don't alter the user-visible random state (issue #336)
const IJulia_RNG = seed!(Random.MersenneTwister(0))
import UUIDs
uuid4() = string(UUIDs.uuid4(IJulia_RNG))

"""
IPython message struct.
"""
mutable struct Msg
    idents::Vector{String}
    header::Dict
    content::Dict
    parent_header::Dict
    metadata::Dict
    function Msg(idents, header::Dict, content::Dict,
                 parent_header=Dict{String,Any}(), metadata=Dict{String,Any}())
        new(idents,header,content,parent_header,metadata)
    end
end

verbose::Bool = IJULIA_DEBUG

@kwdef mutable struct Kernel
    verbose::Bool = IJULIA_DEBUG
    inited::Bool = false
    current_module::Module = Main

    # These fields are special and are mirrored to their corresponding global
    # variables.
    In::Dict{Int, String} = Dict{Int, String}()
    Out::Dict{Int, Any} = Dict{Int, Any}()
    ans::Any = nothing
    n::Int = 0
    capture_stdout::Bool = true
    capture_stderr::Bool = !IJULIA_DEBUG

    postexecute_hooks::Vector{Function} = Function[]
    preexecute_hooks::Vector{Function} = Function[]
    posterror_hooks::Vector{Function} = Function[]
    shutdown::Function = exit

    # the following constants need to be initialized in init().
    publish::RefValue{Socket} = Ref{Socket}()
    raw_input::RefValue{Socket} = Ref{Socket}()
    requests::RefValue{Socket} = Ref{Socket}()
    control::RefValue{Socket} = Ref{Socket}()
    heartbeat::RefValue{Socket} = Ref{Socket}()
    heartbeat_context::RefValue{Context} = Ref{Context}()
    profile::Dict{String, Any} = Dict{String, Any}()
    connection_file::Union{String, Nothing} = nothing
    read_stdout::RefValue{Base.PipeEndpoint} = Ref{Base.PipeEndpoint}()
    read_stderr::RefValue{Base.PipeEndpoint} = Ref{Base.PipeEndpoint}()
    socket_locks = Dict{Socket, ReentrantLock}()
    hmacstate::RefValue{MbedTLS.MD{true}} = Ref{MbedTLS.MD{true}}()

    requests_task::RefValue{Task} = Ref{Task}()
    watch_stdout_task::RefValue{Task} = Ref{Task}()
    watch_stderr_task::RefValue{Task} = Ref{Task}()
    watch_stdout_timer::RefValue{Timer} = Ref{Timer}()
    watch_stderr_timer::RefValue{Timer} = Ref{Timer}()

    # name=>iobuffer for each stream ("stdout","stderr") so they can be sent in flush
    bufs::Dict{String, IOBuffer} = Dict{String, IOBuffer}()
    # max output per code cell is 512 kb by default
    max_output_per_request::RefValue{Int} = Ref(1 << 19)

    # Variable so that display can be done in the correct Msg context
    execute_msg::Msg = Msg(["julia"], Dict("username"=>"jlkernel", "session"=>uuid4()), Dict())
    # Variable tracking the number of bytes written in the current execution request
    stdio_bytes::RefValue{Int} = Ref(0)
    # Use an array to accumulate "payloads" for the execute_reply message
    execute_payloads::Vector{Dict} = Dict[]

    heartbeat_threadid::Vector{Int} = zeros(Int, 128) # sizeof(uv_thread_t) <= 8 on Linux, OSX, Win

    # queue of objects to display at end of cell execution
    displayqueue::Vector{Any} = Any[]
end

function Base.setproperty!(value::Kernel, name::Symbol, x)
    # These fields are isbits types and need to be assigned explicitly to their
    # global counterparts.
    if name âˆˆ (:ans, :n, :In, :Out, :inited, :verbose)
        setproperty!(IJulia, name, x)
    end

    setfield!(value, name, x)
end

function Base.close(kernel::Kernel)
    close(kernel.publish[])
    close(kernel.raw_input[])
    close(kernel.requests[])
    close(kernel.control[])
    close(kernel.heartbeat_context[])

    if kernel.capture_stdout
        redirect_stdout(orig_stdout[])
        close(kernel.watch_stdout_timer[])
        close(kernel.read_stdout[])
        wait(kernel.watch_stdout_task[])
    end
    if kernel.capture_stderr
        redirect_stderr(orig_stderr[])
        close(kernel.watch_stderr_timer[])
        close(kernel.read_stderr[])
        wait(kernel.watch_stderr_task[])
    end
    redirect_stdin(orig_stdin[])

    Logging.global_logger(orig_logger[])

    # Reset all the global variables
    kernel.inited = false
    IJulia.ans = nothing
    IJulia.n = 0
    IJulia.verbose = IJULIA_DEBUG
    IJulia._default_kernel = nothing
end

function Kernel(f::Function, profile; kwargs...)
    kernel = Kernel(; kwargs...)
    init([], kernel, profile)

    try
        f(kernel)
    finally
        close(kernel)
    end
end

_default_kernel::Union{Kernel, Nothing} = nothing

"""
    set_verbose(v=true)

This function enables (or disables, for `set_verbose(false)`) verbose
output from the IJulia kernel, when called within a running notebook.
This consists of log messages printed to the terminal window where
`jupyter` was launched, displaying information about every message sent
or received by the kernel.   Used for debugging IJulia.
"""
function set_verbose(v::Bool=true; kernel=_default_kernel)
    kernel.verbose = v
end

"""
`inited` is a global variable that is set to `true` if the IJulia
kernel is running, i.e. in a running IJulia notebook.  To test
whether you are in an IJulia notebook, therefore, you can check
`isdefined(Main, :IJulia) && IJulia.inited`.
"""
inited::Bool = false

set_current_module(m::Module; kernel=_default_kernel) = kernel.current_module = m

#######################################################################
include("jupyter.jl")
#######################################################################

"""
    load_string(s, replace=false)

Load the string `s` into a new input code cell in the running IJulia notebook,
somewhat analogous to the `%load` magics in IPython. If the optional argument
`replace` is `true`, then `s` replaces the *current* cell rather than creating
a new cell.
"""
function load_string(s::AbstractString, replace::Bool=false)
    push!(execute_payloads, Dict(
        "source"=>"set_next_input",
        "text"=>s,
        "replace"=>replace
    ))
    return nothing
end

"""
    load(filename, replace=false)

Load the file given by `filename` into a new input code cell in the running
IJulia notebook, analogous to the `%load` magics in IPython.
If the optional argument `replace` is `true`, then the file contents
replace the *current* cell rather than creating a new cell.
"""
load(filename::AbstractString, replace::Bool=false) =
    load_string(read(filename, String), replace)

#######################################################################
# History: global In/Out and other exported history variables
"""
`In` is a global dictionary of input strings, where `In[n]`
returns the string for input cell `n` of the notebook (as it was
when it was *last evaluated*).
"""
In::Dict{String, Any} = Dict{String, Any}()
"""
`Out` is a global dictionary of output values, where `Out[n]`
returns the output from the last evaluation of cell `n` in the
notebook.
"""
Out::Dict{String, Any} = Dict{String, Any}()
"""
`ans` is a global variable giving the value returned by the last
notebook cell evaluated.
"""
ans::Any = nothing

# execution counter
"""
`IJulia.n` is the (integer) index of the last-evaluated notebook cell.
"""
n::Int = 0

#######################################################################
# methods to clear history or any subset thereof

function clear_history(indices; kernel=_default_kernel)
    for n in indices
        delete!(kernel.In, n)
        if haskey(kernel.Out, n)
            delete!(kernel.Out, n)
        end
    end
end

# since a range could be huge, intersect it with 1:n first
clear_history(r::AbstractRange{<:Integer}) =
    invoke(clear_history, Tuple{Any}, intersect(r, 1:n))

function clear_history(; kernel=_default_kernel)
    empty!(kernel.In)
    empty!(kernel.Out)
    kernel.ans = nothing
end

"""
    clear_history([indices])

The `clear_history()` function clears all of the input and output
history stored in the running IJulia notebook.  This is sometimes
useful because all cell outputs are remember in the `Out` global variable,
which prevents them from being freed, so potentially this could
waste a lot of memory in a notebook with many large outputs.

The optional `indices` argument is a collection of indices indicating
a subset of cell inputs/outputs to clear.
"""
clear_history

#######################################################################
# methods to print history or any subset thereof
function history(io::IO, indices::AbstractVector{<:Integer}; kernel=_default_kernel)
    for n in intersect(indices, 1:kernel.n)
      if haskey(kernel.In, n)
        print(io, kernel.In[n])
      end
    end
end

history(io::IO, x::Union{Integer,AbstractVector{<:Integer}}...) = history(io, vcat(x...))
history(x...) = history(stdout, x...)
history(io::IO, x...) = throw(MethodError(history, (io, x...,)))
history(; kernel=_default_kernel) = history(1:kernel.n)
"""
    history([io], [indices...])

The `history()` function prints all of the input history stored in
the running IJulia notebook in a format convenient for copying.

The optional `indices` argument is one or more indices or collections
of indices indicating a subset input cells to print.

The optional `io` argument is for specifying an output stream. The default
is `stdout`.
"""
history

#######################################################################
# Similar to the ipython kernel, we provide a mechanism by
# which modules can register thunk functions to be called after
# executing an input cell, e.g. to "close" the current plot in Pylab.
# Modules should only use these if isdefined(Main, IJulia) is true.

"""
    push_postexecute_hook(f::Function)

Push a function `f()` onto the end of a list of functions to
execute after executing any notebook cell.
"""
push_postexecute_hook(f::Function; kernel=_default_kernel) = push!(kernel.postexecute_hooks, f)
"""
    pop_postexecute_hook(f::Function)

Remove a function `f()` from the list of functions to
execute after executing any notebook cell.
"""
pop_postexecute_hook(f::Function; kernel=_default_kernel) =
    splice!(kernel.postexecute_hooks, findlast(isequal(f), kernel.postexecute_hooks))

"""
    push_preexecute_hook(f::Function)

Push a function `f()` onto the end of a list of functions to
execute before executing any notebook cell.
"""
push_preexecute_hook(f::Function; kernel=_default_kernel) = push!(kernel.preexecute_hooks, f)
"""
    pop_preexecute_hook(f::Function)

Remove a function `f()` from the list of functions to
execute before executing any notebook cell.
"""
pop_preexecute_hook(f::Function; kernel=_default_kernel) =
    splice!(kernel.preexecute_hooks, findlast(isequal(f), kernel.preexecute_hooks))

# similar, but called after an error (e.g. to reset plotting state)
"""
    pop_posterror_hook(f::Function)

Remove a function `f()` from the list of functions to
execute after an error occurs when a notebook cell is evaluated.
"""
push_posterror_hook(f::Function; kernel=_default_kernel) = push!(kernel.posterror_hooks, f)
"""
    pop_posterror_hook(f::Function)

Remove a function `f()` from the list of functions to
execute after an error occurs when a notebook cell is evaluated.
"""
pop_posterror_hook(f::Function; kernel=_default_kernel) =
    splice!(kernel.posterror_hooks, findlast(isequal(f), kernel.posterror_hooks))

#######################################################################

# The user can call IJulia.clear_output() to clear visible output from the
# front end, useful for simple animations.  Using wait=true clears the
# output only when new output is available, for minimal flickering.
"""
    clear_output(wait=false)

Call `clear_output()` to clear visible output from the current notebook
cell.  Using `wait=true` clears the output only when new output is
available, which reduces flickering and is useful for simple animations.
"""
function clear_output(wait=false; kernel=_default_kernel)
    # flush pending stdio
    flush_all(; kernel)
    empty!(displayqueue) # discard pending display requests
    send_ipython(kernel.publish[], msg_pub(kernel.execute_msg::Msg, "clear_output",
                                           Dict("wait" => wait)))
    kernel.stdio_bytes[] = 0 # reset output throttling
end


"""
    set_max_stdio(max_output::Integer)

Sets the maximum number of bytes, `max_output`, that can be written to stdout and
stderr before getting truncated. A large value here allows a lot of output to be
displayed in the notebook, potentially bogging down the browser.
"""
function set_max_stdio(max_output::Integer; kernel)
    kernel.max_output_per_request[] = max_output
end


#######################################################################

include("init.jl")
include("hmac.jl")
include("eventloop.jl")
include("stdio.jl")
include("msg.jl")
include("display.jl")
include("magics.jl")
include("comm_manager.jl")
include("execute_request.jl")
include("handlers.jl")
include("heartbeat.jl")
include("inline.jl")

end # IJulia
